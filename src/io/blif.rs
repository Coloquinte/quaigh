use std::io::Write;

use crate::network::{BinaryType, NaryType, TernaryType};
use crate::{Gate, Network, Signal};

use super::utils::{get_inverted_signals, sig_to_string};

pub fn write_blif_cube<W: Write>(w: &mut W, mask: usize, num_vars: usize, val: bool) {
    for i in 0..num_vars {
        let val_i = (mask >> i) & 1 != 0;
        write!(w, "{}", if val_i { "1" } else { "0" }).unwrap();
    }
    write!(w, "{}", if val { " 1" } else { " 0" }).unwrap();
}

/// Write a network in .blif format
///
/// The format specification is available [here](https://course.ece.cmu.edu/~ee760/760docs/blif.pdf),
/// with extensions introduced by [ABC](https://people.eecs.berkeley.edu/~alanmi/publications/other/boxes01.pdf)
/// and [Yosys](https://yosyshq.readthedocs.io/projects/yosys/en/latest/cmd/write_blif.html) and
/// [VPR](https://docs.verilogtorouting.org/en/latest/vpr/file_formats/).
///
/// Quaigh only support a small subset, with a single module and a single clock.
/// ```
pub fn write_blif<W: Write>(w: &mut W, aig: &Network) {
    writeln!(w, "# .blif file").unwrap();
    writeln!(w, "# Generated by quaigh").unwrap();
    writeln!(w, ".model quaigh").unwrap();

    // Write input specifiers
    write!(w, ".inputs").unwrap();
    for i in 0..aig.nb_inputs() {
        write!(w, " {}", aig.input(i)).unwrap();
    }
    writeln!(w).unwrap();

    // Write output specifiers
    write!(w, ".outputs").unwrap();
    for i in 0..aig.nb_outputs() {
        write!(w, " {}", sig_to_string(&aig.output(i))).unwrap();
    }
    writeln!(w).unwrap();

    // Write latches
    for i in 0..aig.nb_nodes() {
        if let Gate::Dff([d, en, res]) = aig.gate(i) {
            if *en != Signal::one() || *res != Signal::zero() {
                // ABC extension to blif
                write!(w, ".flop D={} Q=x{} init=0", sig_to_string(d), i).unwrap();
                if *en != Signal::one() {
                    write!(w, " E={}", en).unwrap();
                }
                if *res != Signal::zero() {
                    write!(w, " R={}", en).unwrap();
                }
                writeln!(w).unwrap();
            } else {
                writeln!(w, ".latch {} x{} 0", sig_to_string(d), i).unwrap();
            }
        }
    }
    writeln!(w).unwrap();

    // Write gates
    for i in 0..aig.nb_nodes() {
        let g = aig.gate(i);
        if !g.is_comb() {
            continue;
        }
        write!(w, ".names").unwrap();
        for s in g.dependencies() {
            write!(w, " {}", sig_to_string(s)).unwrap();
        }
        writeln!(w, " x{}", i).unwrap();

        match g {
            Gate::Binary(_, BinaryType::And) => {
                writeln!(w, "11 1").unwrap();
            }
            Gate::Binary(_, BinaryType::Xor) => {
                writeln!(w, "10 1").unwrap();
                writeln!(w, "01 1").unwrap();
            }
            Gate::Ternary(_, TernaryType::And) => {
                writeln!(w, "111 1").unwrap();
            }
            Gate::Ternary(_, TernaryType::Xor) => {
                writeln!(w, "111 1").unwrap();
                writeln!(w, "100 1").unwrap();
                writeln!(w, "010 1").unwrap();
                writeln!(w, "001 1").unwrap();
            }
            Gate::Ternary(_, TernaryType::Mux) => {
                writeln!(w, "11- 1").unwrap();
                writeln!(w, "0-1 1").unwrap();
            }
            Gate::Ternary(_, TernaryType::Maj) => {
                writeln!(w, "11- 1").unwrap();
                writeln!(w, "-11 1").unwrap();
                writeln!(w, "1-1 1").unwrap();
            }
            Gate::Nary(v, tp) => {
                if matches!(
                    tp,
                    NaryType::And | NaryType::Nand | NaryType::Nor | NaryType::Or
                ) {
                    let input_inv = matches!(tp, NaryType::Nor | NaryType::Or);
                    let output_inv = matches!(tp, NaryType::Or | NaryType::Nand);
                    for _ in 0..v.len() {
                        if input_inv {
                            write!(w, "0").unwrap();
                        } else {
                            write!(w, "1").unwrap();
                        }
                    }
                    if output_inv {
                        writeln!(w, " 0").unwrap();
                    } else {
                        writeln!(w, " 1").unwrap();
                    }
                } else {
                    for mask in 0usize..(1 << v.len()) {
                        let xor_val = mask.count_ones() % 2 != 0;
                        let val = match tp {
                            NaryType::Xor => xor_val,
                            NaryType::Xnor => !xor_val,
                            _ => unreachable!(),
                        };
                        if val {
                            write_blif_cube(w, mask, v.len(), val);
                        }
                    }
                }
            }
            Gate::Buf(_) => {
                write!(w, "0 1").unwrap();
            }
            Gate::Lut(lut) => {
                for mask in 0..lut.lut.num_bits() {
                    let val = lut.lut.value(mask);
                    if val {
                        write_blif_cube(w, mask, lut.lut.num_vars(), val);
                    }
                }
            }
            _ => panic!("Gate type not supported"),
        }
    }

    // Write inverters
    let signals_with_inv = get_inverted_signals(aig);
    for s in signals_with_inv {
        writeln!(w, ".names {} {}_n", s, s).unwrap();
        writeln!(w, "0 1").unwrap();
    }

    // Write constants
    writeln!(w, ".names vdd").unwrap();
    writeln!(w, "1").unwrap();
    writeln!(w, ".names gnd").unwrap();
}
