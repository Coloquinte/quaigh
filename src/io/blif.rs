use std::io::Write;

use crate::{
    network::{BinaryType, TernaryType},
    Gate, NaryType, Network, Signal,
};

use super::utils::{get_inverted_signals, sig_to_string};

/// Write a network in .blif format
///
/// The format specification is available [here](https://course.ece.cmu.edu/~ee760/760docs/blif.pdf),
/// with extensions introduced by [ABC](https://people.eecs.berkeley.edu/~alanmi/publications/other/boxes01.pdf)
/// and [Yosys](https://yosyshq.readthedocs.io/projects/yosys/en/latest/cmd/write_blif.html) and
/// [VPR](https://docs.verilogtorouting.org/en/latest/vpr/file_formats/).
///
/// Quaigh only support a small subset, with a single module and a single clock.
/// ```
pub fn write_blif<W: Write>(w: &mut W, aig: &Network) {
    writeln!(w, "# .blif file").unwrap();
    writeln!(w, "# Generated by quaigh").unwrap();
    writeln!(w, ".model quaigh").unwrap();

    // Write input specifiers
    write!(w, ".inputs").unwrap();
    for i in 0..aig.nb_inputs() {
        write!(w, " {}", aig.input(i)).unwrap();
    }
    writeln!(w).unwrap();

    // Write output specifiers
    write!(w, ".outputs").unwrap();
    for i in 0..aig.nb_outputs() {
        write!(w, " {}", sig_to_string(&aig.output(i))).unwrap();
    }
    writeln!(w).unwrap();

    // Write latches
    for i in 0..aig.nb_nodes() {
        if let Gate::Dff([d, en, res]) = aig.gate(i) {
            if *en != Signal::one() || *res != Signal::zero() {
                // ABC extension to blif
                write!(w, ".flop D={} Q=x{} init=0", sig_to_string(d), i).unwrap();
                if *en != Signal::one() {
                    write!(w, " E={}", en).unwrap();
                }
                if *res != Signal::zero() {
                    write!(w, " R={}", en).unwrap();
                }
                writeln!(w).unwrap();
            } else {
                writeln!(w, ".latch {} x{} 0", sig_to_string(d), i).unwrap();
            }
        }
    }
    writeln!(w).unwrap();

    // Write gates
    for i in 0..aig.nb_nodes() {
        let g = aig.gate(i);
        if !g.is_comb() {
            continue;
        }
        write!(w, ".names").unwrap();
        for s in g.dependencies() {
            write!(w, " {}", sig_to_string(s)).unwrap();
        }
        writeln!(w, " x{}", i).unwrap();

        match g {
            Gate::Binary(_, BinaryType::And) => {
                writeln!(w, "11 1").unwrap();
            }
            Gate::Binary(_, BinaryType::Xor) => {
                writeln!(w, "10 1").unwrap();
                writeln!(w, "01 1").unwrap();
            }
            Gate::Ternary(_, TernaryType::And) => {
                writeln!(w, "111 1").unwrap();
            }
            Gate::Ternary(_, TernaryType::Xor) => {
                writeln!(w, "111 1").unwrap();
                writeln!(w, "100 1").unwrap();
                writeln!(w, "010 1").unwrap();
                writeln!(w, "001 1").unwrap();
            }
            Gate::Ternary(_, TernaryType::Mux) => {
                writeln!(w, "11- 1").unwrap();
                writeln!(w, "0-1 1").unwrap();
            }
            Gate::Ternary(_, TernaryType::Maj) => {
                writeln!(w, "11- 1").unwrap();
                writeln!(w, "-11 1").unwrap();
                writeln!(w, "1-1 1").unwrap();
            }
            Gate::Nary(v, tp) => {
                if matches!(
                    tp,
                    NaryType::And | NaryType::Nand | NaryType::Nor | NaryType::Or
                ) {
                    let input_inv = matches!(tp, NaryType::Nor | NaryType::Or);
                    let output_inv = matches!(tp, NaryType::Or | NaryType::Nand);
                    for _ in 0..v.len() {
                        if input_inv {
                            write!(w, "0").unwrap();
                        } else {
                            write!(w, "1").unwrap();
                        }
                    }
                    if output_inv {
                        writeln!(w, " 0").unwrap();
                    } else {
                        writeln!(w, " 1").unwrap();
                    }
                } else {
                    // TODO: implement N-ary Xor
                    todo!("N-input xor not yet implemented for Blif")
                }
            }
            Gate::Buf(_) => {
                write!(w, "0 1").unwrap();
            }
            Gate::Lut(_) => todo!(),
            _ => panic!("Gate type not supported"),
        }
    }

    // Write inverters
    let signals_with_inv = get_inverted_signals(aig);
    for s in signals_with_inv {
        writeln!(w, ".names {} {}_n", s, s).unwrap();
        writeln!(w, "0 1").unwrap();
    }

    // Write constants
    writeln!(w, ".names vdd").unwrap();
    writeln!(w, "1").unwrap();
    writeln!(w, ".names gnd").unwrap();
}
